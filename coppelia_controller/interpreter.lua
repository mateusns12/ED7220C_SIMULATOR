--  INTERPRETER

local sim = require('sim')

require(sim.getObject("/switch"))
require(sim.getObject("/tokenizer"))
require(sim.getObject("/parser"))
require(sim.getObject("/robot"))
require(sim.getObject("/emitter"))
require(sim.getObject("/runtime"))

Interpreter = {}

local f = string.format

-- @brief Interpreter object Constructor
function Interpreter:new()
    Interpreter.__index = Interpreter
    local Attributes = {
        ops = nil,
        enabled = false,
        emitter = nil, 
        robot = nil
    }
    return setmetatable(Attributes,Interpreter)
end

-- @brief This function syncs simulation with real robot. 
--        It blocks interpreter, until both of them returns.
-- @param (table cmd) Table with arguments generated by Parser
function Interpreter:exec(cmd)
    self.robot.arg = cmd
    if Runtime.connected then self.emitter.arg = cmd end
    -- We disable stepping mode, to enable Shceduler Auto Yield back.
    -- This allows sim.wait() function to work in non blocking mode.
    sim.setStepping(false) -- same as setAutoYield(false)
    -- While any arg is not nil, the task is still unfinished.
    while self.robot.arg or self.emitter.arg do 
        Runtime.resume(robot_coro)
        if Runtime.connected then Runtime.resume(emit_coro) end
    end
    sim.setStepping(true)
    -- Stepping enabled back, to speed up interpreter.
end

-- @param (table ops) Array of instructions from parser  
function Interpreter:run(ops)
    self.ops = ops
    local eval = Evaluator:new()
    local idx = 1
    local advance = function() idx = idx + 1 end
    local function unpack_args(args)
        local values = {}
        for i=1,#args do push(values,eval:eval(args[i])) end
        return values
    end
    local function validate_signals(sig)
        for i=1,#sig do
            if math.abs(sig[i]) < 1 or math.abs(sig[i]) > 8 then return false end
        end
        return true 
    end
    -- We enable stepping mode to disable Scheduler Auto Yield
    -- since for Program instructions, functions should not be interrupted
    -- They are enabled back once Robot or Emitter starts
    -- This leads to 20x faster execution for program instructions,
    -- but UI does not respond, so we disable and enable again in the loop.
    sim.setStepping(true) -- same as setAutoYield(false)
    while idx <= #self.ops do
        if not Runtime.enabled then break end
        local cmd = self.ops[idx]
        if not Runtime.paused then
        ---------------------- PROGRAM ----------------------
            if cmd[1] == 'TYPE' then
                local p = f("%s",eval:eval(cmd[2]))
                if not cmd[3] then p = p .. "\n" end
                CB.AppendConsole(p)
            elseif cmd[1] == 'IF' then
                local result = eval:eval(cmd[2])
                if result == false then advance() end   
            elseif cmd[1] == 'GOTO' then
                idx = Symbols.labels[cmd[2]]
            elseif cmd[1] == 'SETI'
                or cmd[1] == 'ASSIGN'then
                local var = Symbols.globals[cmd[2]]
                if not var then push(Symbols.globals[cmd[2]],{'NUM',eval:eval(cmd[3])})
                else var[#var] = {'NUM',eval:eval(cmd[3])}
                end
            elseif cmd[1] == 'END' then
                Runtime.enabled = false
            elseif cmd[1] == 'LOCAL' then
                local sub = Symbols.subs
                Runtime.assert(sub[#sub],'LOCAL',"Local variable outside of a subroutine")
                if not Runtime.enabled then break end
                push(sub[#sub],cmd[2])
                push(Symbols.globals[cmd[2]],{'NUM',0})
            elseif cmd[1] == 'GOSUB' then
                push(Symbols.subs,{cmd[2],idx})
                idx = Symbols.labels[cmd[2]]
            elseif cmd[1] == 'RETURN' then
                local ret = pop(Symbols.subs)
                for i=3,#ret do
                    local var = Symbols.globals[ret[i]]; pop(var)
                end
                idx = ret[2]
            elseif cmd[1] == 'FOR' then
                local var = Symbols.globals[cmd[2]]
                if eval:eval(var[#var]) > eval:eval(cmd[3]) then
                    idx = cmd[4]
                end
            elseif cmd[1] == 'NEXT' then
                local var = Symbols.globals[cmd[2]]
                var[#var][2] = eval:eval(var[#var])+1
                idx = cmd[3]
                if Runtime.paused then idx = idx + 1 end
            elseif cmd[1] == 'INPUT' then
                v = tonumber(CB.Input(cmd[2][2]))
                Runtime.assert(v,'INPUT',"Not a valid number. Enter again")
                if not Runtime.enabled then
                    Runtime.enabled = true
                    idx = idx - 1
                else
                    local var = Symbols.globals[cmd[3]]
                    if not var then push(Symbols.globals[cmd[3]],{'NUM',v})
                    else var[#var] = {'NUM',v}
                    end
                end
            elseif cmd[1] == 'PAUSE' then
                local delay = eval:eval(cmd[2])
            --    sim.setStepping(true)
                sim.wait(delay,false)
            --    sim.setStepping(false)
            ------------------------ NOP ------------------------
            elseif cmd[1] == 'LABEL' then
            elseif cmd[1] == 'CLS' then
            ----------------------- ROBOT -----------------------
            elseif cmd[1] == 'MOVE'
                or cmd[1] == 'MOVETO' then
                cmd[4] = unpack_args(cmd[2])
                --Runtime.assert(validate_range(cmd[2]),cmd[1],'Out of Bounds')
                --if not Runtime.enabled then break end
                self:exec(cmd)
            elseif cmd[1] == 'OUTSIG'
                or cmd[1] == 'WAITFOR'
                or cmd[1] == 'IFSIG' then
                cmd[4] = unpack_args(cmd[2])
                Runtime.assert(validate_signals(cmd[4]),cmd[1],'Out of Bounds')
                if not Runtime.enabled then break end
                self:exec(cmd)
                if cmd[1] == 'IFSIG' then if cmd[3] == false then advance() end end
            elseif cmd[1] == 'MOVEP' then
                cmd[4] = Symbols.points[cmd[2]]
                self:exec(cmd)
            elseif cmd[1] == 'VEL' then
                cmd[4] = eval:eval(cmd[3])
                Runtime.assert(cmd[4]>=0 and cmd[4]<=100,cmd[1],'Out of Bounds')
                if not Runtime.enabled then break end
                self:exec(cmd)
            else
                self:exec(cmd)
            end
            
            advance()
        end
        -- In Fast Mode, this thread does not yield, so UI blocks.
        -- In normal mode, this fast switching allows UI to respond.
        if not Runtime.fastMode then 
            sim.setStepping(false)
            sim.setStepping(true)
        end
    end
    sim.setStepping(false)
end
